<html xmlns="http://www.w3.org/1999/xhtml">
<head xmlns:c="http://cnx.rice.edu/cnxml" xmlns:md="http://cnx.rice.edu/mdml"><title>Digital Input and Output with the MSP430</title><meta name="created-time" content="2011/05/27 14:27:18.262 GMT-5"/><meta name="revised-time" content="2011/08/16 13:47:32.677 GMT-5"/><meta name="author" content="mwjhnsn"/><meta name="acl-list" content="mwjhnsn"/><meta name="licensor" content="mwjhnsn"/><meta name="license" content="http://creativecommons.org/licenses/by/3.0/"/><meta name="keywords" content="Echo, Elec 220, GPIO, Memory Mapped, MSP430, Polling"/><meta name="subject" content="Science and Technology"/></head>

<body xmlns="http://www.w3.org/1999/xhtml" xmlns:c="http://cnx.rice.edu/cnxml" xmlns:md="http://cnx.rice.edu/mdml" xmlns:qml="http://cnx.rice.edu/qml/1.0" xmlns:mod="http://cnx.rice.edu/#moduleIds" xmlns:bib="http://bibtexml.sf.net/" xmlns:data="http://www.w3.org/TR/html5/dom.html#custom-data-attribute" data-cnxml-to-html-ver="1.3.3"><div data-type="document-title">Digital Input and Output with the MSP430</div><div data-type="abstract">This module goes over the basics of digital I/O and the digital interface between a microcontroller and the outside world.</div>
  

<section data-depth="1" id="eip-694"><h3 data-type="title">Basic Digital I/O in the Real World</h3><p id="eip-159">
In this lab you'll go over the basics of how to setup and use the GPIO on the MSP430.  This will allow you to get data from the outside world, run some processing on it, and then output it again as useful information.  You only have one task this week:
</p><ol id="eip-id1164269118078" type="1"><li>
Coding in MSP430 assembly, <strong>write a simple I/O echo program</strong>.  Setup the GPIO pins and poll the input switches for any changes.  On a change, take the input and display it to the output. Step through this program to observe how it behaves. <a href="#eip-872">Assignment Details</a>
</li>
</ol></section><section data-depth="1" id="eip-823"><h3 data-type="title">Digital I/O Basics</h3><section data-depth="2" id="eip-61"><h4 data-type="title">GPIO</h4><div data-type="list" id="eip-896"><div data-type="title">Philosophy</div><ul><li>The MSP430 uses a limited number of GPIO hardware pins that are assignable to several functions depending on your specific model and your program's needs.  Our version, the MSP430G2231, can have the Port_1 pins act as digital output, digital input, or ADC input.</li>
<li>The pins are organized into ports, with each port usually one byte (8 bits/pins) wide.  On larger versions of the processor (different format chips with physically many more pins...) you can encounter several ports, but in this lab you will only be using Port_1 and Port_2</li>
<li>You can set each pin's function independently (input or output) by modifying some memory mapped I/O registers.  Since we want to do both, we will divide P1 into half inputs and half outputs as needed.</li></ul></div><div data-type="list" id="eip-108"><div data-type="title">Usage</div><ul><li>The I/O ports are memory mapped into the top of the MSP430 address space.</li>
<li>There are several registers associated with each port.  For now, you only need to worry about four (P1IN, P1OUT, P1DIR, and P1REN).
<div data-type="list" id="eip-219"><div data-type="title">P1IN</div><ul data-bullet-style="none"><li>The P1IN register is located at address <code data-display="inline"> 0x0020</code> in memory, which you can also refer to using the C symbol <code data-display="inline"> &amp;P1IN</code></li>
<li>The register holds the values the MSP430 sees at each pin, regardless of the pin direction setting.</li>
<li>To read the register, it is good practice to use a <code data-display="inline">mov.b</code> instruction to avoid accidentally reading adjacent registers</li>
<li><div data-type="note" id="eip-id1167848724614" data-label="tip" data-element-type="tip">If you are looking to test or read just the pins set to input, you will have to mask the P1IN register to zero out the other unwanted/output pins.  Reading P1IN reads the entire port, regardless of pin direction.</div></li></ul></div>

<div data-type="list" id="eip-614"><div data-type="title">P1OUT</div><ul data-bullet-style="none"><li>The P1OUT register is located at address <code data-display="inline"> 0x0021</code> in memory, which you can also refer to using the C symbol <code data-display="inline"> &amp;P1OUT</code></li>
<li>If their direction bits in P1DIR are set to output/ "1", the corresponding pins will output the values set in P1OUT.</li>
<li>If a pin's direction bits are set to input in P1DIR and its resistors are enabled in P1REN, P1OUT controls the pin's connection to the pull-up resistor.  Setting P1OUT to "1" enables the pull-up, while setting it to "0" leaves the input to float in a high impedance state.</li>
<li>To set P1OUT, use a <code data-display="inline"> mov.b</code> instruction to set several pins at once.  To set individual bits to "1", you can use an <code data-display="inline">or.b</code> instruction with a "1" in the positions you want to set.  To clear individual bits/ set them to zero, use an <code data-display="inline"> and.b</code> instruction with mostly "1"s except for a "0" for the bits you want to clear.</li></ul></div>

<div data-type="list" id="eip-140"><div data-type="title">P1DIR</div><ul data-bullet-style="none"><li>The P1DIR register is located at address <code data-display="inline"> 0x0022</code> in memory, which you can also refer to using the C symbol <code data-display="inline"> &amp;P1DIR</code></li>
<li>The value of the bits in P1DIR determines whether the MSP430 hardware leaves the pin in a high impedance state where it responds to external voltage changes (which you can read at P1IN), or in a low impedance state where the MSP430 drives the output voltage to a certain value determined by P1OUT.</li>
<li>To set the bit directions all at once, use a <code data-display="inline">mov.b</code> instruction, but to change individual bits regardless of the others, use an <code data-display="inline">and.b</code> or a <code data-display="inline">or.b</code> </li>
<li><strong>Set the corresponding bits to "0" to set pins to input mode, or to "1" to set them to output mode.</strong></li></ul></div><div data-type="list" id="eip-309"><div data-type="title">P1REN</div><ul data-bullet-style="none"><li>The P1REN register is located at address <code data-display="inline"> 0x0027</code> in memory, which you can also refer to using the C symbol <code data-display="inline"> &amp;P1REN</code></li>
<li>P1REN controls whether the MSP430 Launchpad enables the integrated pull-up resistor for a given pin.</li>
<li>The pull-up resistors allow the use of single pole switches.  They prevent the input signals from floating randomly while the switches are open by loosely tying the inputs to Vcc.  When the switch is closed though, the much stronger connection to ground wins out, pulling the inputs down to GND.</li>
<li><strong>Set the corresponding bits to "1" to enable a pin's pull-up resistor, or to "0" to disable it (disabled by default).</strong></li></ul></div>
</li></ul></div></section><section data-depth="2" id="eip-1"><h4 data-type="title">So What?</h4><p id="eip-240">In this lab we're going to use the MSP430's GPIO pins, combined with some external switches and an LED display, to build a basic I/O system for our board.  Because of how things fit together on the board, it makes sense to use P1.0-P1.3 (the first three Port_1 GPIO Pins) to read the input switches and P1.4-P1.7 for the output signals.  </p>

<p id="eip-224"><span data-type="title">Outputs</span>Setting up the outputs is easy-- simply set the upper four bits (bits 4-7) of <code data-display="inline">&amp;P1DIR</code> to "1", and then write the output to the upper four bits of <code data-display="inline">&amp;P1OUT</code>.  That means you'll have to shift your data left 4 positions before output, but you should already know a simple technique to do so!
</p><div data-type="note" id="eip-359" data-label="aside" data-element-type="aside">You'll notice that when you change the output, the corresponding input bits also change.  This happens because the input hardware always reads the status of the line, regardless if it is set to input our output.  Changing the <code data-display="inline">&amp;P1DIR</code> values only connects or disconnects the driving circuitry built into the MSP430.  In advanced applications this can be used to analyze potential faults in the circuitry outside the chip.</div><p id="eip-995"><span data-type="title">Inputs</span>Inputs are also "easy," but there are a few hardware concepts you'll need before you understand how they work!</p><section data-depth="3" id="eip-529"><h5 data-type="title">A Little Bit About Wires</h5><p id="eip-416">As mentioned briefly in class, binary digital logic has two valid states, plus one third mystery state.  That third state, "The High Impedance State," (High-Z) just means that the wire isn't connected to anything.  You've already talked about using so called tri-state buffers to negotiate who can talk on a shared bus-- the listening components enter the high impedance state, allowing the transmitting component's signal to drive the bus with no conflicts.

</p><div data-type="note" id="eip-id1167686202560" data-label="aside" data-element-type="aside">Impedance is a generalized form of the classical Resistance concept.  Impedances can be real or complex valued, and apply too signals expressed in complex exponential form (<strong>whether constant or variable!</strong>).  To learn more about impedance, check out Dr. Johnson's sections from <a href="/contents/1292758b-63a9-4d16-935c-25bdfd593e4f" target="_window">the Elec 241 course notes.</a>
</div>


<figure id="basicSwitch"><div data-type="title">A Basic Switch </div><span data-type="media" id="eip-id2610023" data-alt="A simple SPST hardware switch">
<img src="/resources/35a8eb61c0b5fea9f66b7a2e0d35008e39616f1d/Switch.png" data-media-type="image/png" alt="A simple SPST hardware switch" width="600"/>
</span>
</figure><p id="eip-458">In order to read useful input from your switches, you need them to be "0" in one state, and "1" in the other.  Yet knowing what you know about the third state, the switch shown above will actually give a "0"/"1" (depending on what you connect it to) when closed and "High-Z" when open.  Because there's nothing else driving the sensor input besides our switch, <strong> the input value will be random when the switch is open</strong>.  In digital logic this is called floating, and it is a very very bad thing.  </p>

<p id="eip-292">One simple solution is the <strong>Pull-Up (or Pull-Down) Resistor</strong>.  Connecting the floating side of the switch to a logic level through a large resistor will tie down the floating input when the switch is open, but won't effect the read value much when the switch is closed.
</p>

<figure id="basicPullUp"><figcaption>As you can see, when the switch is closed, the input is shorted to ground and reads zero.  When the switch is open, the pull-up resistor holds the previously floating end at Vcc.</figcaption><span data-type="media" id="eip-id1168361611348" data-alt="An spst hardware switch in the pulled up configuration.  One end of the switch is grounded, while the other is connected to the circuit input and Vcc through a large resistor.">
<img src="/resources/b91e9ee3f172b6315cd023f7c843b3d397652047/Simple Pullup.png" data-media-type="image/png" alt="An spst hardware switch in the pulled up configuration.  One end of the switch is grounded, while the other is connected to the circuit input and Vcc through a large resistor." width="600"/>
</span>
</figure><p id="eip-848"><span data-type="title">Pull-Ups in the MSP430</span>For better or for worse, the MSP430 actually has pull up resistors already built into the chip's hardware.  Configuring them takes several steps, but once setup they provide all the functionality above without the extra external connections.
</p><ul id="eip-id1165028523721" data-element-type="enumerated" data-bullet-style="asterisk"><li>
Set the Pin Direction for P1.0-P1.3 to input.  (Set bits 0-3 of <code data-display="inline">&amp;P1DIR</code> to "0")
</li>
<li>
Enable the resistors themselves.  (Set bits 0-3 of <code data-display="inline">&amp;P1REN</code> to "1")
</li>
<li>
Configure the resistors to be pull-up.  (Set bits 0-3 of <code data-display="inline">&amp;P1OUT</code> to "1")
</li>
</ul><div data-type="note" id="eip-id1165033492932" data-label="important" data-element-type="important">The most confusing part of the whole process is the double function of <code data-display="inline">P1OUT</code>.  Because of the hardware implementation on the MSP430, <code data-display="inline">&amp;P1OUT</code> controls the outputs as well as the connections to the pull up resistors.  <strong>You will need to ensure that every time you output a value, you KEEP the lower four bits "1"</strong>.  The easiest way to do this is just by ORing your raw output with the constant <code data-display="inline">#0Fh</code> before you write to <code data-display="inline">P1OUT</code>.  The MSP430 does not have a specific "or" instruction by name, but <code data-display="inline">bis</code> does the same thing.  For more info on <code data-display="inline">bis</code> and its inverse <code data-display="inline">bic</code>, see <a href=""> next week's lab.</a></div>

<figure id="msp430ResistorSetup"><figcaption>Notice that configured this way, the MSP430 GPIO pin takes the form of the simplified Pull-Up figure above.</figcaption><span data-type="media" id="eip-id1083621" data-alt="The MSP430 resistor connection configuration.  Shows the double function of P1OUT">
<img src="/resources/aa6f0549aa853f66bf90f3563965833aa2523bbb/MSP430 GPIO Diagram.png" data-media-type="image/png" alt="The MSP430 resistor connection configuration.  Shows the double function of P1OUT" width="600"/>
</span>
</figure></section>

</section><section data-depth="2" id="eip-760"><h4 data-type="title">Polling</h4><div data-type="list" id="eip-283"><div data-type="title">Philosophy</div><ul data-bullet-style="bullet"><li>A traditional single threaded polling scheme consists of a main loop that runs continuously.  Within that loop, the processor periodically checks for changes, and if there are none, continues looping.  Once a change is detected, the program moves to a new section of code or calls a new subroutine to deal with the changes.</li>
<li>Polling has advantages and disadvantages-- it keeps program execution linear and is very easy to code and implement, but it also is not incredibly responsive.  Since polling only checks values at certain points in the main run loop, if the loop is long or changes occur quickly, a polling scheme can miss input data.  For now though it will suffice.</li>
</ul></div></section></section><section data-depth="1" id="eip-872"><h3 data-type="title">Assignment Details</h3><p id="eip-32">Your task is to code a simple input to output echo program for the MSP430.  Your program should consist of:
</p><ul id="eip-id1165937309871"><li>A setup section that runs once and configures the GPIO pins</li>
<li>A main loop that runs infinitely</li>
<li>Code inside your loop to read the state of the GPIO input pins</li>
<li>A separate section of code to write the changes to the output pins and then return to the main loop</li>
</ul><div data-type="note" id="eip-465" data-label="tip" data-element-type="tip"><div data-type="title">Masking</div>You should already know the basics of masking from class, but it becomes very important when dealing with I/O.  Since different pins do different things in the same port (P1), you the programmer will have to be careful not to accidentally modify the wrong bits even though your instructions will operate on the entire register.</div></section><p id="eip-121">All images drawn by Matt Johnson, Rice ECE</p>
</body>

</html>