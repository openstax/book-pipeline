import { readFileSync, writeFileSync } from 'fs'
import * as path from "path";
import { GIT_PDF_STEPS, GIT_WEB_STEPS, ARCHIVE_PDF_STEPS, ARCHIVE_GDOC_STEPS, ARCHIVE_WEB_STEPS_WITH_DEQUEUE_AND_UPLOAD, Step, GIT_WEB_STEPS_WITH_DEQUEUE_AND_UPLOAD, GIT_GDOC_STEPS } from './step-definitions'

const DIRS_TO_SKIP = new Set()
DIRS_TO_SKIP.add('book')

function ensure<T>(v: T | undefined | null, message?: string) {
    /* istanbul ignore if */
    if (!message) message = `BUG: value was expected to be truthy but instead was ${v}`
    /* istanbul ignore else */
    if (v) {
        return v
    } else {
        throw new Error(message)
    }
}

type Edge = {
    dirName: string
    from: string
    to: string
}

function buildChart(steps: Step[], additionalResource?: string) {
    const edges: Edge[] = []
    const prevOutputs = new Map<string, string>() // directory, stepName

    // Add the concourse resources as inputs
    if (additionalResource) {
        steps.unshift({name: 'Misc-Resources', inputs: [], outputs: [additionalResource], env: {}})
    }

    steps.forEach(step => {
        step.inputs.forEach(dir => {
            if (DIRS_TO_SKIP.has(dir)) { return }
            const from = ensure(prevOutputs.get(dir), `Step '${step.name}' has an input directory of '${dir}' but no previous step has that as an output directory`)
            const to = step.name
            edges.push({dirName: dir, from, to})
        })
        step.outputs.forEach(dir => {
            if (DIRS_TO_SKIP.has(dir)) { return }
            prevOutputs.set(dir, step.name)
        })
    })

    // Generate a MermaidJS file: https://mermaid-js.github.io/mermaid/#/examples?id=basic-flowchart
    const lines: string[] = []
    lines.push('graph TB') // top-to-bottom
    function addEdge(e: Edge) {
        lines.push(`    ${e.from} -- ${e.dirName} --> ${e.to}`)
    }
    edges.forEach(e => addEdge(e))
    /*
        ```mermaid
        ${lines.join('\n')}
        ```
    */
    return `\`\`\`mermaid
${lines.join('\n')}
\`\`\``
}


const charts: Array<[string, string]> = []
charts.push(['all-git-pdf', buildChart(GIT_PDF_STEPS)])
charts.push(['all-git-web', buildChart(GIT_WEB_STEPS_WITH_DEQUEUE_AND_UPLOAD, 's3-git-queue')])
charts.push(['all-git-gdoc', buildChart(GIT_GDOC_STEPS)])
charts.push(['all-archive-pdf', buildChart(ARCHIVE_PDF_STEPS)])
charts.push(['all-git-web', buildChart(ARCHIVE_WEB_STEPS_WITH_DEQUEUE_AND_UPLOAD, 's3-archive-queue')])
charts.push(['all-archive-gdocs', buildChart(ARCHIVE_GDOC_STEPS)])

const readmeMarkdown = `This file contains autogenerated images of the different pipelines.

They are generated by running \`npm run build:graphs\` in the parent directory.

${charts.map(([name]) => `- [${name}](#${name})`).join('\n')}

${charts.map(([name, markup]) => `
## ${name}

${markup}`).join('\n')}
`

writeFileSync(path.resolve('./graphs/README.md'), readmeMarkdown)

// Update the graphs in the main README
let mainReadme = readFileSync(path.resolve('../README.md'), 'utf-8')
let foundGraph = false
charts.forEach(([name, markup]) => {
    const start = `<!-- AUTOGEN-GRAPH-START:${name} -->`
    const end = `<!-- AUTOGEN-GRAPH-END:${name} -->`
    const re = new RegExp(`${start}.*${end}`, 's')
    if (re.test(mainReadme)) {
        foundGraph = true
    }
    mainReadme = mainReadme.replace(re, `${start}
${markup}
${end}`)
})
/* istanbul ignore if */
if (!foundGraph) {
    throw new Error('BUG: Readme no longer contains any graphs in it. Remove this code')
}

writeFileSync(path.resolve('../README.md'), mainReadme)